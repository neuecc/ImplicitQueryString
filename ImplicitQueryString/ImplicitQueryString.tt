<#@ template language="C#" #>
<#@ output extension="cs" #>
<#@ assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Reflection" #>
<#
    var methods = typeof(Convert).GetMethods(BindingFlags.Static | BindingFlags.Public);

    var converters = methods.Where(x => x.Name.StartsWith("To"))
        .Select(x => Regex.Replace(x.Name, "^To", ""))
        .Where(x => !x.StartsWith("Base64") && x != "String")
        .Distinct();
#>
using System;
using System.Collections.Generic;
using System.Collections.Specialized;

namespace CodePlex.Web
{
    public static class NameValueCollectionExtensions
    {
        public static ConvertableString ParseValue(this NameValueCollection source, string key)
        {
            return ParseValue(source, key, null);
        }

        public static ConvertableString ParseValue(this NameValueCollection source, string key, Func<string, string> converter)
        {
            var values = source.GetValues(key);
            if (values == null) throw new KeyNotFoundException();

            var value = values[0];
            return new ConvertableString(converter == null ? value : converter(value));
        }

        public static T ParseEnum<T>(this NameValueCollection source, string key)
            where T : struct, IComparable, IFormattable, IConvertible
        {
            return ParseEnum<T>(source, key, null, true);
        }

        public static T ParseEnum<T>(this NameValueCollection source, string key, Func<string, string> converter)
            where T : struct, IComparable, IFormattable, IConvertible
        {
            return ParseEnum<T>(source, key, converter, true);
        }

        public static T ParseEnum<T>(this NameValueCollection source, string key, bool ignoreCase)
            where T : struct, IComparable, IFormattable, IConvertible
        {
            return ParseEnum<T>(source, key, null, ignoreCase);
        }

        public static T ParseEnum<T>(this NameValueCollection source, string key, Func<string, string> converter, bool ignoreCase)
            where T : struct, IComparable, IFormattable, IConvertible
        {
            var values = source.GetValues(key);
            if (values == null) throw new KeyNotFoundException();

            var value = values[0];
            return (T)Enum.Parse(typeof(T), converter == null ? value : converter(value), ignoreCase);
        }

<# foreach (var converter in converters) { #>
        public static <#= converter #> ParseValueOrDefault(this NameValueCollection source, string key, <#= converter #> defaultValue)
        {
            return ParseValueOrDefault(source, key, defaultValue, null);
        }

        public static <#= converter #> ParseValueOrDefault(this NameValueCollection source, string key, <#= converter #> defaultValue, Func<string, string> converter)
        {
            var values = source.GetValues(key) ?? new string[0];
            if (values.Length != 0)
            {
                var value = values[0];
                <#= converter #> result;
                if (value != null && <#= converter #>.TryParse(converter == null ? value : converter(value), out result))
                {
                    return result;
                }
                else
                {
                    return defaultValue;
                }
            }

            return defaultValue;
        }

<# } #>
        public static T ParseEnumOrDefault<T>(this NameValueCollection source, string key)
            where T : struct, IComparable, IFormattable, IConvertible
        {
            return ParseEnumOrDefault(source, key, default(T), null, false);
        }

        public static T ParseEnumOrDefault<T>(this NameValueCollection source, string key, T defaultValue)
            where T : struct, IComparable, IFormattable, IConvertible
        {
            return ParseEnumOrDefault(source, key, defaultValue, null, false);
        }

        public static T ParseEnumOrDefault<T>(this NameValueCollection source, string key, T defaultValue, Func<string, string> converter)
            where T : struct, IComparable, IFormattable, IConvertible
        {
            return ParseEnumOrDefault(source, key, defaultValue, converter, false);
        }

        public static T ParseEnumOrDefault<T>(this NameValueCollection source, string key, T defaultValue, bool ignoreCase)
            where T : struct, IComparable, IFormattable, IConvertible
        {
            return ParseEnumOrDefault(source, key, defaultValue, null, ignoreCase);
        }

        public static T ParseEnumOrDefault<T>(this NameValueCollection source, string key, T defaultValue, Func<string, string> converter, bool ignoreCase)
            where T : struct, IComparable, IFormattable, IConvertible
        {
            var values = source.GetValues(key) ?? new string[0];
            if (values.Length != 0)
            {
                var value = values[0];
                T result;
                if (value != null && TryParsePrivate(converter == null ? value : converter(value), ignoreCase, out result))
                {
                    return result;
                }
                else
                {
                    return defaultValue;
                }
            }

            return defaultValue;
        }

        public static bool ContainsKey(this NameValueCollection source, string key)
        {
            return source.GetValues(key) != null;
        }

        // for .NET 3.5 compatibility
        static bool TryParsePrivate<T>(string value, bool ignoreCase, out T result)
        {
            try
            {
                result = (T)Enum.Parse(typeof(T), value, ignoreCase);
                return true;
            }
            catch
            {
                result = default(T);
                return false;
            }
        }
    }

    public struct ConvertableString
    {
        public readonly string Value;

        public ConvertableString(string value)
        {
            this.Value = value;
        }

<# foreach (var converter in converters) { #>
        public static implicit operator <#= converter #>(ConvertableString self)
        {
            return <#= converter #>.Parse(self.Value);
        }

        public static implicit operator <#= converter #>?(ConvertableString self)
        {
            <#= converter #> value;
            return (self.Value != null && <#= converter #>.TryParse(self.Value, out value))
                ? new Nullable<<#= converter #>>(value)
                : null;
        }

<# } #>
        public static implicit operator String(ConvertableString self)
        {
            return self.Value;
        }

        public override string ToString()
        {
            return Value;
        }
    }
}